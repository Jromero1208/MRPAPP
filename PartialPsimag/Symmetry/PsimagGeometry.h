
//-*-C++-*-    

#ifndef PSIMAG_GEOMETRY_HEADER_H
#define PSIMAG_GEOMETRY_HEADER_H

//! \file PsiGeometry.h
//! \brief Geometry/Symmetry generated by psimag

#include "GroupActionFilter.h"
#include "DcaCrystal.h"

#include "fetchGeometry1D.h"  
#include "fetchGeometry2D.h"
#include "fetchMeshWignerSeitz.h"


namespace rpa {

  /*! 
   */
  template<typename Field, 
	   template<typename> class MatrixTemplate>
  class PsimagGeometry {

	   public:
	     
	     typedef Crystal<Field, MatrixTemplate> CrystalType;
	     typedef MatrixTemplate<Field>          MatrixType;
	     
	     
	     //! Sets sitesKmesh based on a minimum distance algorithm
	     static
	     void getMeshGeometry(int dim,
				  int numPoints,
				  const MatrixType& sitesK,
				  MatrixType&       sitesKmesh)
	     {
	       fetchMeshGeometry(dim,numPoints,sitesK,sitesKmesh);
	     }
	     
	     static
	     void getGeometry1D(int length1d,
				Crystal<Field,MatrixTemplate>& rCrystal,
				Crystal<Field,MatrixTemplate>& kCrystal)
	     {
	       fetchGeometry1D(length1d,rCrystal,kCrystal);
	     }
	     
	     template<typename VectorLikeType>
	     static
	     void getGeometry2D(Field latticeA_length, 
				Field latticeB_length, 
				Field latticeAngle,
				int superlatticeA_x,
				int superlatticeA_y,
				int superlatticeB_x,
				int superlatticeB_y,
				GroupActionFilter::Type  filterType,
				Crystal<Field,MatrixTemplate>& rCluster,
				const VectorLikeType&          phase,
				Crystal<Field,MatrixTemplate>& kCluster,
				int                            parallelProcessingId=-911)
	     {
	       fetchGeometry2D(latticeA_length, 
			       latticeB_length, 
			       latticeAngle,
			       superlatticeA_x,
			       superlatticeA_y,
			       superlatticeB_x,
			       superlatticeB_y,
			       filterType,
			       rCluster,
			       phase,
			       kCluster,
			       parallelProcessingId);
	     }
	     
	   };
  
} // namespace rpa

/*@}*/
#endif
